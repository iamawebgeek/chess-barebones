"use strict";(self.webpackChunkchess_barebones_docs=self.webpackChunkchess_barebones_docs||[]).push([[7785],{1134:(e,s,r)=>{r.d(s,{R:()=>t,x:()=>o});var a=r(3917);const c={},n=a.createContext(c);function t(e){const s=a.useContext(n);return a.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:t(e.components),a.createElement(n.Provider,{value:s},e.children)}},2212:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>i,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"guides/core-concepts","title":"Core Concepts","description":"This guide explains the core concepts of the Chess barebones library.","source":"@site/docs/guides/core-concepts.md","sourceDirName":"guides","slug":"/guides/core-concepts","permalink":"/docs/guides/core-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/iamawebgeek/chess-barebones/tree/main/docs/docs/guides/core-concepts.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Philosophy","permalink":"/docs/getting-started/philosophy"},"next":{"title":"React Integration","permalink":"/docs/guides/react-integration"}}');var c=r(1273),n=r(1134);const t={sidebar_position:1},o="Core Concepts",i={},d=[{value:"The Game Loop",id:"the-game-loop",level:2},{value:"The Board",id:"the-board",level:2},{value:"Figures",id:"figures",level:2},{value:"Players",id:"players",level:2},{value:"Handlers",id:"handlers",level:2},{value:"Serializers",id:"serializers",level:2},{value:"Observable State",id:"observable-state",level:2}];function l(e){const s={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",...(0,n.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(s.header,{children:(0,c.jsx)(s.h1,{id:"core-concepts",children:"Core Concepts"})}),"\n",(0,c.jsx)(s.p,{children:"This guide explains the core concepts of the Chess barebones library."}),"\n",(0,c.jsx)(s.h2,{id:"the-game-loop",children:"The Game Loop"}),"\n",(0,c.jsxs)(s.p,{children:["The ",(0,c.jsx)(s.code,{children:"Game"})," class from ",(0,c.jsx)(s.code,{children:"@chess-barebones/core"})," is the heart of the library. It orchestrates the game loop, manages players, and handles moves. The ",(0,c.jsx)(s.code,{children:"Game"})," class is a generic class that can be used to create any turn-based, board-centric game."]}),"\n",(0,c.jsx)(s.h2,{id:"the-board",children:"The Board"}),"\n",(0,c.jsxs)(s.p,{children:["The ",(0,c.jsx)(s.code,{children:"AbstractBoard"})," class represents the game board. It is responsible for managing the state of the board, including the positions of all the pieces. The ",(0,c.jsx)(s.code,{children:"@chess-barebones/core"})," package includes one concrete implementation: ",(0,c.jsx)(s.code,{children:"Board8x8"}),"."]}),"\n",(0,c.jsx)(s.h2,{id:"figures",children:"Figures"}),"\n",(0,c.jsxs)(s.p,{children:["The ",(0,c.jsx)(s.code,{children:"AbstractFigure"})," class represents a piece on the board. It is an abstract class that must be extended to create a specific type of figure. The ",(0,c.jsx)(s.code,{children:"@chess-barebones/chess"})," package provides concrete implementations of ",(0,c.jsx)(s.code,{children:"AbstractFigure"})," for all the standard chess pieces."]}),"\n",(0,c.jsx)(s.h2,{id:"players",children:"Players"}),"\n",(0,c.jsxs)(s.p,{children:["The ",(0,c.jsx)(s.code,{children:"Player"})," class represents a participant in the game. A ",(0,c.jsx)(s.code,{children:"Player"})," is initialized with a ",(0,c.jsx)(s.code,{children:"color"})," and a ",(0,c.jsx)(s.code,{children:"flank"}),"."]}),"\n",(0,c.jsx)(s.h2,{id:"handlers",children:"Handlers"}),"\n",(0,c.jsxs)(s.p,{children:["Handlers are objects that implement the ",(0,c.jsx)(s.code,{children:"Handler"})," interface, which allows you to hook into various game events, such as ",(0,c.jsx)(s.code,{children:"onStart"}),", ",(0,c.jsx)(s.code,{children:"onMove"}),", and ",(0,c.jsx)(s.code,{children:"onEnd"}),". You can use handlers to implement custom game logic, such as checking for checkmate or stalemate."]}),"\n",(0,c.jsx)(s.h2,{id:"serializers",children:"Serializers"}),"\n",(0,c.jsxs)(s.p,{children:["Serializers are responsible for serializing and deserializing moves. The ",(0,c.jsx)(s.code,{children:"@chess-barebones/chess"})," package includes an ",(0,c.jsx)(s.code,{children:"AlgebraicNotationSerializer"})," that can serialize and deserialize moves in standard algebraic notation."]}),"\n",(0,c.jsx)(s.h2,{id:"observable-state",children:"Observable State"}),"\n",(0,c.jsxs)(s.p,{children:["The ",(0,c.jsx)(s.code,{children:"ObservableState"})," class is a base class for creating stateful, subscribable objects. The ",(0,c.jsx)(s.code,{children:"Game"}),", ",(0,c.jsx)(s.code,{children:"AbstractBoard"}),", ",(0,c.jsx)(s.code,{children:"AbstractFigure"}),", and ",(0,c.jsx)(s.code,{children:"Player"})," classes all extend ",(0,c.jsx)(s.code,{children:"ObservableState"}),"."]}),"\n",(0,c.jsxs)(s.p,{children:["This allows you to subscribe to changes in the state of these objects and react accordingly. For example, you can subscribe to the ",(0,c.jsx)(s.code,{children:"Game"})," object to be notified when the game starts or ends, or you can subscribe to a ",(0,c.jsx)(s.code,{children:"Player"})," object to be notified when the player's score changes."]}),"\n",(0,c.jsxs)(s.p,{children:["The ",(0,c.jsx)(s.code,{children:"@chess-barebones/chess-react"})," package provides the ",(0,c.jsx)(s.code,{children:"useObservablesState"})," hook, which makes it easy to subscribe to ",(0,c.jsx)(s.code,{children:"ObservableState"})," instances in a React component."]})]})}function h(e={}){const{wrapper:s}={...(0,n.R)(),...e.components};return s?(0,c.jsx)(s,{...e,children:(0,c.jsx)(l,{...e})}):l(e)}}}]);