"use strict";(self.webpackChunkchess_barebones_docs=self.webpackChunkchess_barebones_docs||[]).push([[5529],{1134:(e,r,t)=>{t.d(r,{R:()=>o,x:()=>a});var i=t(3917);const n={},s=i.createContext(n);function o(e){const r=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),i.createElement(s.Provider,{value:r},e.children)}},8551:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"api-reference/core/board","title":"Board","description":"AbstractBoard","source":"@site/docs/api-reference/core/board.md","sourceDirName":"api-reference/core","slug":"/api-reference/core/board","permalink":"/chess-barebones/docs/api-reference/core/board","draft":false,"unlisted":false,"editUrl":"https://github.com/iamawebgeek/chess-barebones/tree/main/docs/docs/api-reference/core/board.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Game","permalink":"/chess-barebones/docs/api-reference/core/game"},"next":{"title":"Figure","permalink":"/chess-barebones/docs/api-reference/core/figure"}}');var n=t(1273),s=t(1134);const o={sidebar_position:3},a="Board",d={},c=[{value:"<code>AbstractBoard&lt;T extends string&gt;</code>",id:"abstractboardt-extends-string",level:2},{value:"Properties",id:"properties",level:3},{value:"Methods",id:"methods",level:3},{value:"<code>Board8x8&lt;T extends string&gt;</code>",id:"board8x8t-extends-string",level:2}];function l(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.header,{children:(0,n.jsx)(r.h1,{id:"board",children:"Board"})}),"\n",(0,n.jsx)(r.h2,{id:"abstractboardt-extends-string",children:(0,n.jsx)(r.code,{children:"AbstractBoard<T extends string>"})}),"\n",(0,n.jsx)(r.p,{children:"An abstract class for representing a game board."}),"\n",(0,n.jsx)(r.h3,{id:"properties",children:"Properties"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"lastMoved: AbstractFigure<T, NotCaptured> | null"}),": The last figure that was moved."]}),"\n"]}),"\n",(0,n.jsx)(r.h3,{id:"methods",children:"Methods"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"createFigure(name: T, owner: Player, coordinate: Coordinate | string): AbstractFigure<T, NotCaptured>"}),": Creates a figure and adds it to the board."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"replaceFigure(figure: AbstractFigure<T, NotCaptured>, name: T): AbstractFigure<T, NotCaptured>"}),": Replaces a figure with a new one (e.g., for pawn promotion)."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"getFigure(coordinate: Coordinate | string): AbstractFigure<T, NotCaptured> | null"}),": Returns the figure at a given coordinate."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"getAllFigures(): AbstractFigure<T, Captured | NotCaptured>[]"}),": Returns all figures on the board, including captured ones."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"getPlayerFigures(player: Player): AbstractFigure<T, Captured | NotCaptured>[]"}),": Returns all figures belonging to a specific player."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"getPlayerFiguresByName(player: Player, figureName: T): AbstractFigure<T, Captured | NotCaptured>[]"}),": Returns all figures of a specific type belonging to a specific player."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"getFiguresReachCoordinate(coordinate: Coordinate): AbstractFigure<T, NotCaptured>[]"}),": Returns all figures that can reach a given coordinate."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"getPathBetweenCoordinates(base: Coordinate, end: Coordinate): Coordinate[]"}),": Returns the path between two coordinates."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"serializePosition(): string"}),": Serializes the entire board position to a string."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"loadPosition(serializedPosition: string, players: Record<string, Player>): void"}),": Loads a board position from a serialized string."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"getCoordinateWithVector(coordinate: Coordinate, vector: [number, number]): Coordinate | null"}),": Returns a new coordinate by applying a vector to an existing coordinate."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"serializeCoordinate(coordinate: Coordinate): string"}),": Serializes a coordinate to a string."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"deserializeCoordinate(coordinate: string): Coordinate"}),": Deserializes a string to a coordinate."]}),"\n"]}),"\n",(0,n.jsx)(r.h2,{id:"board8x8t-extends-string",children:(0,n.jsx)(r.code,{children:"Board8x8<T extends string>"})}),"\n",(0,n.jsxs)(r.p,{children:["This class extends ",(0,n.jsx)(r.code,{children:"AbstractBoard"}),' and provides an implementation for a standard 8x8 board. It uses algebraic-like coordinates (e.g., "e4") for serialization and deserialization.']})]})}function u(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}}}]);